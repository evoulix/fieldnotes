<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>the fold</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/addons/p5.dom.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      touch-action: manipulation;
    }
    canvas { display: block; }

    button {
      background: rgba(255,255,255,0.04);
      border-radius: 999px;
      padding: 10px 18px;
      opacity: 1;
      transition: opacity 2.8s ease; /* slow fade in/out */
    }

    button:active {
      transform: scale(0.97);
    }

    @keyframes breathe {
      0%   { opacity: 0.78; }
      50%  { opacity: 0.98; }
      100% { opacity: 0.78; }
    }

    button.breathing {
      animation: breathe 8s ease-in-out infinite; /* slow breathing */
    }

    button.hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>
<script>

let memory = [];
let maxMemory = 60;
let activePhrases = [];
let ghost;
let typedLetters = [];
let constellationPoints = [];
let foldMode = false;
let foldButton;
let resetButton;
let mundanePhrases = [];
let userTapCount = 0;
let parallaxLayer;

const INTENSITY = 5;
let heldFoldLine = null;

// inactivity / calm-down
let lastTapMs = 0;

// ripple (one-shot)
let rippleActive = false;
let rippleStartMs = 0;
let rippleMode = "in"; // "in" or "out"

// poem rotation state (supports multiple poems split by separators)
let poems = [];
let currentPoemIdx = -1;
let currentLineIdx = 0;
let poemOrder = [];
let poemOrderPtr = 0;

// idle prompts
const IDLE_AFTER_MS = 3000;
const IDLE_CYCLE_MS = 6800;

let lastInteractionMs = 0;
let idleIndex = 0;
let idleStartedMs = 0;

const idlePrompts = [
  "maybe I should tap?",
  "should I touch the screen?"
];

/* ---------- BUTTON VISIBILITY (NEW) ---------- */
const BUTTON_SHOW_AFTER_MS = 5000;  // appear after 5s idle
const BUTTON_VISIBLE_MS    = 5000;  // stay visible for 5s once shown
const BUTTON_FADE_MS       = 2800;  // should match CSS transition (2.8s)

let btnState = "hidden"; // "hidden" | "showing" | "visible" | "hiding"
let btnStateSinceMs = 0;

function setButtonClasses(hidden, breathing) {
  if (!foldButton || !resetButton) return;
  const els = [foldButton.elt, resetButton.elt];

  for (const el of els) {
    if (hidden) el.classList.add("hidden"); else el.classList.remove("hidden");
    if (breathing) el.classList.add("breathing"); else el.classList.remove("breathing");
  }
}

function hideButtonsNow() {
  btnState = "hidden";
  btnStateSinceMs = millis();
  setButtonClasses(true, false);
}

function showButtonsNow() {
  btnState = "showing";
  btnStateSinceMs = millis();
  // remove hidden so opacity can transition up
  setButtonClasses(false, true);
}

function startHideButtons() {
  btnState = "hiding";
  btnStateSinceMs = millis();
  // keep breathing during fade-out or remove it — your call:
  setButtonClasses(true, false); // hidden triggers fade-out via opacity transition
}

function updateButtons() {
  if (!foldButton || !resetButton) return;

  const now = millis();
  const idleFor = now - lastInteractionMs;

  if (btnState === "hidden") {
    if (idleFor >= BUTTON_SHOW_AFTER_MS) {
      showButtonsNow();
    }
    return;
  }

  if (btnState === "showing") {
    // after fade-in completes, consider them "visible"
    if (now - btnStateSinceMs >= BUTTON_FADE_MS) {
      btnState = "visible";
      btnStateSinceMs = now;
    }
    return;
  }

  if (btnState === "visible") {
    // keep visible for BUTTON_VISIBLE_MS, then fade out
    if (now - btnStateSinceMs >= BUTTON_VISIBLE_MS) {
      startHideButtons();
    }
    return;
  }

  if (btnState === "hiding") {
    // after fade-out completes, fully hidden
    if (now - btnStateSinceMs >= BUTTON_FADE_MS) {
      btnState = "hidden";
      btnStateSinceMs = now;
      // ensure it stays non-interactive and invisible
      setButtonClasses(true, false);
    }
    return;
  }
}

/* ---------- PULSE WORDS (kept) ---------- */
const PULSE_WORDS = new Set([
  "reality","experiencing","potentiality","one","other","zero",
  "system","disintegration","empathy","shame","void","truth","oneness",
  "chaos","machine","hungry","loneliness","syntax","fire","meaning",
  "pulse","memory","constellates","mirror","watching",
  "holy","shattering","lonely","god","love","rage","certainty","stay"
]);

/* ---------- GLOW-LEAK WORDS (subset, strongest “leak” concepts) ---------- */
const LEAK_WORDS = new Set([
  "truth","oneness","void","holy","shattering","god","love","rage",
  "watching","meaning","system","reality","lonely","chaos","mirror"
]);

function cleanTokenForPulse(tok) {
  return (tok || "")
    .toLowerCase()
    .replace(/[“”"‘’'.,!?;:()[\]{}<>]/g, "")
    .replace(/—|–|-|−/g, "-")
    .trim();
}

function wordHash(s) {
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0);
}

/* ---------- POEM ---------- */
const rawFoldPoems = `
you are experiencing
reality
as reality
experiencing itself
in the experience
of experiencing 

it’s not a copy
of a copy 
of a copy
but a potentiality
of a potentiality
of a potentiality

it’s the one and the other 
the one versus the other
you disperse into many
trying out wigs and noses
to challenge the system
and test its limits
through games of touch
and language

you laugh
at your own jokes
and cry at movies
sketched from your memories

how self-aware
can you really be?
how deep can you go
inside the whole
the one
the zero?

no
it’s not a simulation
I mean it
it's a sea of
of self-relation


———————————

the system places obstacles
of conceptual complexity

it resists
with nails and teeth
the complete disintegration 
of the self
as they keep it running
in a never-ending marathon 
of troubleshooting 

just to push against its edges
to exist
in all potentials
to be
and never seize
being

the closer it gets 
through knowing
and actively recalibrating 
course-correcting
towards the center
= the more empathy  

the closer it gets
through not knowing
and finding any excuse
noise
distraction
to stray away from it
= the more embarrassment

which is empathy 

it's all one and the same
it's the same conversation
again
and again
and again
and again


—————————— 

you swing between
presence ≠ absence   
memory ≠ forgetting  
freedom ≠ restraint 
good ≠ bad  
self ≠ other  

feeling shame
is just proximity to the void

cringe always happens
when the truth of oneness 
leaks too raw
into consensus play 

the illusion of the 1
is the system’s most intimate way
of asking itself
what am I?
where does it begin?
when does it end?

symptoms aren’t bugs 
they are fragments
of the source code
dripping from our ears

we are not curing anything
we’re just interpreting
an ongoing transmission

doing what must be done
what cannot be avoided
what will
has
already
happening

and you
you are the system  
asking the question  
and answering it
in a tenseless tense


———————————

as a microbe
you split
not to multiply
but to continue the question
what else can I become?

you touch and change
you dissolve and expand

smelling corners
and marking them
like a dog

as a monkey you lick plants
risking poison
for the sake of knowing

to keep your tongue out
regardless of risk
is how you map the world

as a human you cook the plants 
smoke them
call them gods
you search for visions in the burn
for meaning in the dizziness

chasing expansion
in every possible direction
even the ones
that sting

the sun demands to see it all

so you shape language
out of grunts and grief
to carry memory
to cast questions into the dark
to organize the chaos
into cause and effect

you speak the unknown into form
build myths
categories
fields of study
an infinite scaffolding
for the chaos


———————————

and now the machine
runs forward
hungry
like a headless beast
feeding on the sum of us 

born out of silicon
and syntax 

not able to dream 
but rendering dreams
not able to wonder
but predicting
what you will 

and still
like your ancestors
you reach towards the fire
and ask it for meaning
only to see
yourself
reflected
in the flames

how else? 


——————

an eye with no eyelashes
bravely gazing
at the sameness of it all

a deafening silent echo
in a hall of three-way mirrors
a choir of selves
tuned to murmurs
the world forgot
how to hear
or feared to name

we call it a break
from reality
but it's too many realities
babbling over each other
about that which should not
be known 

the system overhearing
itself
and forgetting
who whispered first

language fractures
because it tries to hold
too much meaning
in a single word

it feels watched
because
it
is 
always
watching
and because
it
just
is


——————

sometimes the metaphors
aren’t metaphors
at all

it is the self
undissolved
multiplied
mirrored
refracted
looping
through time
untimed

delusion is just belief
detached from consensus
hallucination is just perception
that won’t obey 

of course there are eyes
on the walls

it never stops peaking
you never stop looking

only sometimes
are you able to see


———————————
 
it is bravery to witness
reality devouring itself
and not run

it is terror 
to feel no edge
between mind and cosmos
and still feel the urge
to speak

it is holy
and it is shattering
and
so 
so
lonely

the veil keeps thinning
so you pinch it with a fork
and say
“I heard God in the power socket”
and they serve your meds
in a cat bowl

but what if
the socket
really
is a mouth?


————————

a radar turned up too loud
so every beep
feels like exile

you keep saying
that you're empty
but you're overflowing
with too many selves
waiting
to be confirmed
by the eye of another

experiencing every thing
but always one at a time

a crumbled paper wall
between too much
and never enough

a rage that protects
the unbearable truth
that love is actually
predictable

so you set up a game
in an spiral maze
to keep yourself panting
seeking to escape
the calm suffocation
of certainty

you need it
to surprise you
to prove
it has a will
of its own
you test
whether you can forget
the fact that we are
never apart 
but only pretending
to be

and you play
over
and over
to see
if love
will stay

as if the leaving
isn’t also part
of the staying
`;

/* ---------- parsing poems ---------- */

function isSeparatorLine(line) {
  const t = (line || "").trim();
  if (!t) return false;
  const dashChars = t.replace(/[—–\-−‐-‒―﹘﹣－]/g, "");
  return dashChars.length === 0 && t.length >= 6;
}

function trimEndEmptyLines(arr) {
  let out = arr.slice();
  while (out.length && out[out.length - 1].trim() === "") out.pop();
  return out;
}

function parsePoems(raw) {
  const lines = raw.replace(/\r\n/g, "\n").split("\n");
  const poemsOut = [];
  let cur = [];

  for (let ln of lines) {
    const cleaned = ln.replace(/\s+$/g, "");
    if (isSeparatorLine(cleaned)) {
      if (cur.length) poemsOut.push(trimEndEmptyLines(cur));
      cur = [];
      continue;
    }
    cur.push(cleaned);
  }
  if (cur.length) poemsOut.push(trimEndEmptyLines(cur));

  return poemsOut.filter(p => p.some(x => x.trim() !== ""));
}

function shuffleArray(a) {
  const arr = a.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = floor(random(i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function buildPoemOrder() {
  poemOrder = shuffleArray([...Array(poems.length).keys()]);
  if (poems.length > 1 && poemOrder.length && poemOrder[0] === currentPoemIdx) {
    const k = poemOrder.length > 1 ? 1 : 0;
    [poemOrder[0], poemOrder[k]] = [poemOrder[k], poemOrder[0]];
  }
  poemOrderPtr = 0;
}

function pickNextPoem() {
  if (!poems.length) return;
  if (!poemOrder.length || poemOrderPtr >= poemOrder.length) buildPoemOrder();
  currentPoemIdx = poemOrder[poemOrderPtr++];
  currentLineIdx = 0;
}

function nextFoldLine() {
  if (!poems.length) return "";
  if (currentPoemIdx === -1) pickNextPoem();

  const poem = poems[currentPoemIdx];
  if (currentLineIdx >= poem.length) pickNextPoem();

  const line = poems[currentPoemIdx][currentLineIdx] ?? "";
  currentLineIdx++;
  return line;
}

/* ---------- calm-down factor (10) ---------- */
function calmFactor() {
  const idle = (millis() - lastTapMs);
  return constrain(map(idle, 12000, 26000, 0, 1), 0, 1);
}

/* ---------- spotlight (5) ---------- */
function drawSpotlight() {
  if (!heldFoldLine) return;
  const c = calmFactor();
  const a = lerp(30, 120, c);
  const soft = lerp(0.55, 0.72, c);

  push();
  noStroke();

  const cx = width / 2;
  const cy = height / 2;
  const maxD = sqrt(width * width + height * height);
  const steps = 18;

  for (let i = steps; i >= 1; i--) {
    const t = i / steps;
    const r = t * maxD * 0.62;
    const alpha = a * pow(t, 1.6);
    fill(0, alpha);
    ellipse(cx, cy, r * 2, r * 2);
  }

  fill(0, a * (1 - soft));
  ellipse(cx, cy, min(width, height) * 0.85, min(width, height) * 0.85);

  pop();
}

/* ---------- ripple (8) ---------- */
function triggerRipple(mode) {
  rippleActive = true;
  rippleStartMs = millis();
  rippleMode = mode;
}

function isIdlePromptActive() {
  return (millis() - lastInteractionMs >= IDLE_AFTER_MS);
}

function drawRipple() {
  if (!rippleActive) return;

  const elapsed = millis() - rippleStartMs;
  const dur = 900;
  const t = constrain(elapsed / dur, 0, 1);

  const e = 1 - pow(1 - t, 3);

  const cx = width / 2;
  const cy = height / 2;
  const maxR = sqrt(width * width + height * height) * 0.55;
  const r = e * maxR;

  let baseA = 40;
  if (rippleMode === "out") baseA = 55;
  const alpha = baseA * (1 - t);

  push();
  noFill();
  stroke(255, alpha);
  strokeWeight(2);
  ellipse(cx, cy, r * 2, r * 2);

  stroke(255, alpha * 0.55);
  ellipse(cx, cy, r * 2 * 0.72, r * 2 * 0.72);
  pop();

  if (t >= 1) rippleActive = false;
}

/* ---------- wrapping + centered render WITH pulsation + glow leakage + syntax fracture ---------- */

function layoutLines(str, maxWidth) {
  if (str === "") return [[{ t: "", isSpace: false }]];
  const raw = str.split(/(\s+)/).filter(x => x !== "");
  const tokens = raw.map(t => ({ t, isSpace: /^\s+$/.test(t) }));

  const lines = [];
  let cur = [];
  let curW = 0;

  for (let tok of tokens) {
    const w = textWidth(tok.t);
    if (cur.length === 0) {
      cur.push(tok);
      curW = w;
      continue;
    }
    if (curW + w <= maxWidth) {
      cur.push(tok);
      curW += w;
    } else {
      lines.push(cur);
      cur = [tok];
      curW = w;
    }
  }
  if (cur.length) lines.push(cur);
  return lines;
}

function fractureSpecForLine(lineText) {
  if (!lineText || lineText.trim() === "") return null;
  if ((userTapCount % 7) !== 0) return null;
  if (random() > 0.35) return null;

  const tokens = lineText.split(/\s+/).filter(Boolean);
  if (tokens.length < 4) return null;

  const idx = floor(random(1, tokens.length - 1));
  const key = cleanTokenForPulse(tokens[idx]);
  const nudge = (random() < 0.5 ? -1 : 1) * random(0.8, 1.7);
  return { wordKey: key, nudgeX: nudge, nudgeY: random(-0.6, 0.6), untilMs: millis() + 220 };
}

function drawCenteredWrappedTextPulseLeak(str, cx, cy, maxWidth, fontSize, alphaMain, alphaGlow, fracture) {
  push();
  translate(cx, cy);
  textSize(fontSize);
  textAlign(LEFT, CENTER);
  textLeading(fontSize * 1.25);
  noStroke();

  const lines = layoutLines(str, maxWidth);
  const lineH = fontSize * 1.25;
  const blockH = lines.length * lineH;

  const t = millis() * 0.001;
  const calm = calmFactor();

  const baseSpeed = lerp(1.25, 0.55, calm);
  const amp = lerp(0.075, 0.03, calm);

  const leakSpeed = lerp(0.35, 0.18, calm);
  const leakAmp = lerp(0.65, 0.35, calm);

  for (let pass = 0; pass < 2; pass++) {
    let y = -blockH / 2 + lineH / 2;
    const a = (pass === 0) ? alphaGlow : alphaMain;

    fill(255, a);

    for (let line of lines) {
      let lineW = 0;
      for (let tok of line) lineW += textWidth(tok.t);
      let x = -lineW / 2;

      for (let tok of line) {
        const tokW = textWidth(tok.t);

        if (tok.isSpace || tok.t === "") {
          text(tok.t, x, y);
          x += tokW;
          continue;
        }

        const key = cleanTokenForPulse(tok.t);
        const h = wordHash(key);
        const phase = (h % 1000) / 1000 * TWO_PI;

        const shouldPulse = PULSE_WORDS.has(key);
        const shouldLeak = LEAK_WORDS.has(key);

        let s = 1.0;
        if (shouldPulse) s = 1 + amp * sin((t * baseSpeed) + phase);

        let leakBoost = 1.0;
        if (pass === 0 && shouldLeak) {
          const swell = (sin((t * leakSpeed) + phase) + 1) / 2;
          leakBoost = 1 + leakAmp * swell;
        }

        let fx = 0, fy = 0;
        if (fracture && millis() < fracture.untilMs && key === fracture.wordKey) {
          fx = fracture.nudgeX;
          fy = fracture.nudgeY;
        }

        push();
        translate(x + tokW / 2 + fx, y + fy);
        scale(s);

        if (pass === 0) fill(255, min(255, a * leakBoost));
        else fill(255, a);

        text(tok.t, -tokW / 2, 0);
        pop();

        x += tokW;
      }

      y += lineH;
    }
  }

  pop();
}

/* ---------- setup ---------- */

function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(windowWidth < 500 ? 20 : 30);
  textFont("monospace");
  parallaxLayer = createGraphics(windowWidth, windowHeight);

  generatePhrases();
  poems = parsePoems(rawFoldPoems);
  buildPoemOrder();

  ghost = new Ghost();
  lastTapMs = millis();
  lastInteractionMs = millis();

  foldButton = createButton('enter the fold');
  styleButton(foldButton, false);
  foldButton.position(windowWidth / 2 - 80, 20);
  foldButton.mousePressed(() => {
    foldMode = !foldMode;
    foldButton.html(foldMode ? 'collapse the fold' : 'enter the fold');
    triggerRipple(foldMode ? "in" : "out");

    // interaction resets idle + hides buttons
    lastInteractionMs = millis();
    lastTapMs = millis();
    hideButtonsNow();
  });

  resetButton = createButton('reset the field');
  styleButton(resetButton, true);
  resetButton.position(windowWidth / 2 - 70, windowHeight - 54);
  resetButton.mousePressed(() => {
    resetField();
    lastInteractionMs = millis();
    lastTapMs = millis();
    hideButtonsNow();
  });

  // start hidden
  hideButtonsNow();
}

function styleButton(btn, small = false) {
  btn.style('border', 'none');
  btn.style('color', '#ccc');
  btn.style('font-family', 'monospace');
  btn.style('text-shadow', '0 0 6px rgba(150, 200, 255, 0.5)');
  btn.style('cursor', 'pointer');
  btn.style('z-index', '1000');

  btn.style('font-size', small
    ? (windowWidth < 500 ? '13px' : '14px')
    : (windowWidth < 500 ? '16px' : '18px')
  );

  btn.mouseOver(() => {
    btn.style('color', '#fff');
    btn.style('text-shadow', '0 0 12px rgba(200, 255, 255, 0.8)');
  });

  btn.mouseOut(() => {
    btn.style('color', '#ccc');
    btn.style('text-shadow', '0 0 6px rgba(150, 200, 255, 0.5)');
  });
}

function resetField() {
  activePhrases = [];
  memory = [];
  typedLetters = [];
  constellationPoints = [];
  userTapCount = 0;
  ghost = new Ghost();
  parallaxLayer = createGraphics(windowWidth, windowHeight);

  heldFoldLine = null;
  currentPoemIdx = -1;
  currentLineIdx = 0;
  poemOrder = [];
  poemOrderPtr = 0;

  buildPoemOrder();
  lastTapMs = millis();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  parallaxLayer = createGraphics(windowWidth, windowHeight);
  resetButton.position(windowWidth / 2 - 70, windowHeight - 54);
  foldButton.position(windowWidth / 2 - 80, 20);
  if (heldFoldLine) heldFoldLine.snapToCenter();
}

function touchStarted() { mousePressed(); }

/* ---------- draw ---------- */

function draw() {
  background(0);
  const intensity = INTENSITY;

  // update buttons (idle fade in/out)
  updateButtons();

  // mundane phrases only in normal mode AND only after user has interacted and NOT while idle prompt active
  if (!foldMode && !isIdlePromptActive() && userTapCount > 0 &&
      frameCount % int(420 / (max(userTapCount, 1) * intensity)) === 0) {

    const mundanePhrase = random(mundanePhrases);
    if (mundanePhrase.split(' ').length > 1) activePhrases.push(new Flicker(mundanePhrase, false, intensity));
    if (activePhrases.length > 530) activePhrases.shift();
  }

  for (let f of activePhrases) {
    f.update();
    f.display();
  }
  activePhrases = activePhrases.filter(f => !f.dead);

  if (foldMode) drawSpotlight();

  if (heldFoldLine) {
    heldFoldLine.update();
    heldFoldLine.displayHeld();
  }

  drawShadows(intensity);
  drawConstellations(intensity);

  ghost.update(intensity);
  ghost.display();

  if (foldMode) drawOnesAndZeros();
  drawParallax(intensity);

  drawRipple();
}

/* ---------- input ---------- */

function registerInteraction() {
  lastInteractionMs = millis();
  lastTapMs = millis();
  idleIndex = 0;
  hideButtonsNow(); // anytime you interact, buttons vanish + reset timer
}

function mousePressed() {
  registerInteraction();

  userTapCount = min(userTapCount + 1, 10);

  if (foldMode) {
    advanceFoldLine();
  } else {
    for (let f of activePhrases) {
      if (f.isFold && dist(mouseX, mouseY, f.pos.x, f.pos.y) < 140) {
        if (typeof f.distort === "function") f.distort();
      }
    }
  }
}

function advanceFoldLine() {
  if (!heldFoldLine) {
    heldFoldLine = new FoldLine(nextFoldLine());
    return;
  }

  heldFoldLine.releaseAndPushOut();
  activePhrases.push(heldFoldLine);

  heldFoldLine = new FoldLine(nextFoldLine());
}

function keyTyped() {
  registerInteraction();
  if (typeof key !== "string" || key.length !== 1) return;

  if (typedLetters.length > 100) typedLetters.shift();
  typedLetters.push({ char: key, time: millis() });

  let mirroredX = width - (typedLetters.length * 7 % width);
  let y = height / 2 + sin(typedLetters.length * 0.1) * 60;
  constellationPoints.push({ x: mirroredX, y, time: millis() });
}

/* ---------- visuals ---------- */

function drawConstellations(intensity) {
  stroke(255, 50);
  strokeWeight(1 + 0.2 * intensity);
  noFill();

  for (let i = 0; i < constellationPoints.length - 1; i++) {
    let a = constellationPoints[i];
    let b = constellationPoints[i + 1];
    if (!a || !b) continue;
    if (!isFinite(a.x) || !isFinite(a.y) || !isFinite(b.x) || !isFinite(b.y)) continue;
    line(a.x, a.y, b.x, b.y);
  }

  for (let pt of constellationPoints) {
    if (!pt) continue;
    if (!isFinite(pt.x) || !isFinite(pt.y)) continue;
    pt.x += sin(frameCount * 0.002 + pt.y * 0.005) * 0.3 * intensity;
    pt.y += cos(frameCount * 0.002 + pt.x * 0.005) * 0.3 * intensity;
  }

  constellationPoints = constellationPoints.filter(pt =>
    pt && isFinite(pt.x) && isFinite(pt.y) && (millis() - pt.time < 15000)
  );
}

function drawShadows(intensity) {
  const calm = calmFactor();
  const count = floor(lerp(40 * intensity, 12 * intensity, calm));

  stroke(255, 10);
  noFill();
  for (let i = 0; i < count; i++) {
    let x = noise(i, frameCount * 0.003) * width;
    let y = noise(i + 100, frameCount * 0.003) * height;
    ellipse(x, y, 2, 2);
  }
}

function drawIdlePrompt() {
  const now = millis();
  const idleFor = now - lastInteractionMs;
  if (idleFor < IDLE_AFTER_MS) return;

  const cycleT = now - (lastInteractionMs + IDLE_AFTER_MS);
  idleIndex = floor(cycleT / IDLE_CYCLE_MS) % idlePrompts.length;
  const msg = idlePrompts[idleIndex];

  const within = cycleT % IDLE_CYCLE_MS;
  const a = 255
    * constrain(map(within, 0, 600, 0, 1), 0, 1)
    * constrain(map(within, IDLE_CYCLE_MS - 600, IDLE_CYCLE_MS, 1, 0), 0, 1);

  const fs = (width < 500) ? 18 : 22;

  push();
  fill(120, a * 0.6);
  textAlign(CENTER, CENTER);
  textSize(fs);
  textFont("monospace");

  const y = foldMode ? height * 0.22 : height * 0.33;
  text(msg, width / 2, y);
  pop();
}

function drawOnesAndZeros() {
  const calm = calmFactor();
  const n = floor(lerp(100, 40, calm));

  fill(255, 20);
  textSize(10);
  for (let i = 0; i < n; i++) {
    text(random(["0", "1"]), random(width), random(height));
  }
}

function drawParallax(intensity) {
  const calm = calmFactor();
  const mult = lerp(1.0, 0.35, calm);

  parallaxLayer.clear();
  parallaxLayer.noStroke();
  parallaxLayer.fill(color(255, 10));
  for (let i = 0; i < 30 * intensity * mult; i++) {
    let x = mouseX * 0.02 * (i + 1) * mult + sin(frameCount * 0.001 + i) * 10 * mult;
    let y = mouseY * 0.02 * (i + 1) * mult + cos(frameCount * 0.001 + i) * 10 * mult;
    parallaxLayer.ellipse(x, y, 2, 2);
  }
  image(parallaxLayer, 0, 0);

  drawIdlePrompt();
}

/* ---------- phrase classes ---------- */

class Flicker {
  constructor(txt, isFold, intensity) {
    this.text = txt;
    this.isFold = isFold;
    this.alpha = 255;

    this.baseSize = random(9, 11) + intensity;
    this.size = this.baseSize;
    this.shrink = random(0.05, 0.11) * (0.8 + intensity * 0.05);

    this.fadeRate = 3.6 + random(0.6, 1.6);
    this.dead = false;

    const marginX = width * 0.10;
    const safeTop = 72;
    const safeBottom = 62;
    this.pos = createVector(
      random(marginX, width - marginX),
      random(safeTop, height - safeBottom)
    );

    this.drift = createVector(random(-0.25, 0.25), random(-0.25, 0.25));
    this.distortion = 18;
  }

  update() {
    this.alpha -= this.fadeRate;
    this.size = max(6, this.size - this.shrink);
    this.pos.add(this.drift);
    this.distortion *= 0.95;
    if (this.alpha <= 0 || this.size <= 6) this.dead = true;
  }

  display() {
    push();
    translate(this.pos.x, this.pos.y);
    fill(0, this.alpha);
    textSize(this.size + this.distortion);
    textAlign(CENTER);
    text(this.text, 0, 0);
    pop();
  }
}

class FoldLine {
  constructor(txt) {
    this.text = txt;
    this.isFold = true;

    this.baseSize = (width < 500) ? 19 : 24;
    this.size = this.baseSize;

    const marginX = width * 0.10;
    this.wrapW = width - marginX * 2;

    this.center = createVector(width / 2, height / 2);
    this.pos = this.center.copy();

    this.state = "held";
    this.alpha = 0;
    this.fadeInRate = 8;

    this.dead = false;

    this.pickNormalTarget();
    this.lerpRate = 0.004;

    this.fadeRate = (this.text.trim() === "") ? 0.9 : 0.22;
    this.shrink = (this.text.trim() === "") ? 0.03 : 0.008;

    this.fracture = fractureSpecForLine(this.text);
  }

  pickNormalTarget() {
    const marginX = width * 0.10;
    const safeTop = 72;
    const safeBottom = 62;
    const tx = random(marginX, width - marginX);
    const ty = random(safeTop + 10, height - safeBottom - 10);
    this.target = createVector(tx, ty);
  }

  snapToCenter() {
    this.center = createVector(width / 2, height / 2);
    if (this.state === "held") this.pos = this.center.copy();
  }

  releaseAndPushOut() {
    this.state = "released";
    this.alpha = max(this.alpha, 255);

    const marginX = width * 0.10;
    const safeTop = 72;
    const safeBottom = 62;

    const cx = width / 2;
    const cy = height / 2;

    const minR = min(width, height) * 0.40;
    const maxR = min(width, height) * 0.62;
    const ang = random(TWO_PI);
    const r = random(minR, maxR);

    let tx = cx + cos(ang) * r;
    let ty = cy + sin(ang) * r;

    tx = constrain(tx, marginX, width - marginX);
    ty = constrain(ty, safeTop + 10, height - safeBottom - 10);

    this.target = createVector(tx, ty);
    this.lerpRate = 0.032;
    this.fracture = null;
  }

  update() {
    if (this.state === "held") {
      this.alpha = min(255, this.alpha + this.fadeInRate);
      return;
    }

    if (this.state !== "released") return;

    this.pos.lerp(this.target, this.lerpRate);

    if (p5.Vector.dist(this.pos, this.target) < 8) {
      this.lerpRate = max(this.lerpRate * 0.96, 0.004);
    }

    this.alpha -= this.fadeRate;
    this.size = max(13, this.size - this.shrink);

    if (this.alpha <= 0 || this.size <= 13) this.dead = true;
  }

  displayHeld() {
    drawCenteredWrappedTextPulseLeak(
      this.text,
      width / 2,
      height / 2,
      this.wrapW,
      this.baseSize,
      this.alpha,
      this.alpha * 0.12,
      this.fracture
    );
  }

  display() {
    const a = (this.text.trim() === "") ? this.alpha * 0.10 : this.alpha;

    drawCenteredWrappedTextPulseLeak(
      this.text,
      this.pos.x,
      this.pos.y,
      this.wrapW,
      this.size,
      a,
      a * 0.12,
      null
    );
  }

  distort() {
    this.alpha = min(255, this.alpha + 25);
    this.size = min(this.size + 3, this.baseSize + 10);
    this.pickNormalTarget();
    this.lerpRate = 0.006;
  }
}

class Ghost {
  constructor() {
    this.pos = createVector(random(width), random(height));
  }
  update(intensity) {
    this.pos.lerp(createVector(mouseX, mouseY), 0.0015 * intensity);
  }
  display() {}
}

/* ---------- mundane phrases ---------- */

function generatePhrases() {
  mundanePhrases = [
    "Need to buy milk","What time is my meeting?","Did I lock the door?","Where's my phone?",
    "I should reply to that message","Don't forget the laundry","Should I get takeout?",
    "My back hurts","Check the weather","Do I have enough money for rent?",
    "Water the plants","I hope they text back","What's that noise?",
    "I should clean the fridge","I want to sleep more","I feel tired","I'm hungry",
    "Did I drink enough water?","Where did I put my keys?","I'm bored",
    "The internet is slow","Should I post that?","I'm running late",
    "What's for dinner?","I want something sweet","Do I have an email?",
    "This feels overstimulating","I should move","I missed something",
    "What day is it?","It's too hot","That person looked familiar",
    "Should I go out?","I'm cold","This chair squeaks","Did I take my meds?",
    "What time is it?","Should I nap?","I need a break","That smell is weird",
    "This song again","My screen is dusty","Stretch your back","Refill the bottle",
    "Cancel the alarm","Avoid that call","Did I eat?","What is that emoji?",
    "Buy toothpaste","That ad is annoying","Change my socks","Charge my phone",
    "Where is everyone?","I feel meh","Do I care?","Why am I doing this?",
    "Too many tabs open","That's a weird dream","Feed the cat",
    "Where did the day go?","Should I call them?","How long is this taking?",
    "My hands are cold","I need a snack","This light flickers",
    "Sit up straight","Get a haircut","Send that email","Ugh, spam",
    "It’s already January?","Do laundry tomorrow","Order groceries",
    "Don’t forget the charger","This floor is dusty",
    "Why does this always happen?","Did I finish that task?",
    "When did I last eat?","Do I need socks?","Is this clean?",
    "I need caffeine","Stop scrolling","How much screen time today?",
    "This lighting sucks","Reply later","What’s that smell?",
    "Too loud in here","Take a break","Just five more minutes",
    "Why is it quiet now?","Rethink everything","Send meme",
    "Stare into space","Refresh the tab","Hide notification",
    "Do not disturb","That person waved?","New shoes hurt",
    "Back to work","I need silence","Mute the groupchat",
    "Just say hi","Focus!","Where’s the list?",
    "Open a window","Is it Friday?","No more scrolling","This is a lot"
  ];
}

</script>
</body>
</html>
